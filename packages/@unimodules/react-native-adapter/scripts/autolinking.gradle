import groovy.json.JsonSlurper
import org.gradle.util.VersionNumber

import java.util.regex.Pattern

def generatedFilePackage = "org.unimodules.adapters.react"
def generatedSrcDir = "generated/unimodules/src/main/java"
def generatedFileName = "UnimodulesPackageList.java"

def generatedUnimodulesPackageListTemplate = """
package $generatedFilePackage;

import java.util.Arrays;
import java.util.List;
import org.unimodules.core.interfaces.Package;

public class UnimodulesPackageList {
  public List<Package> getPackageList() {
    return Arrays.<Package>asList(
      {{ unimodulesPackages }}
    );
  }
}
"""

class Colors {
  static final String NORMAL = '\u001B[0m'
  static final String RED = '\u001B[31m'
  static final String GREEN = '\u001B[32m'
  static final String YELLOW = '\u001B[33m'
  static final String MAGENTA = '\u001B[35m'

  static String red(String str) {
    return RED + str + NORMAL
  }
  static String green(String str) {
    return GREEN + str + NORMAL
  }
  static String yellow(String str) {
    return YELLOW + str + NORMAL
  }
  static String magenta(String str) {
    return MAGENTA + str + NORMAL
  }
}

String ERR_AUTOLINKING_NOT_CONFIGURED = """
Unimodules autolinking failed - make sure you invoke ${Colors.green('unimodules.includeProjects')} method in your ${Colors.yellow('settings.gradle')} file.
"""

class Unimodule {
  String name
  List platforms
  List targets
  List androidPackages
  String directory
  String version
  String androidGroup
  String androidSubdirectory

  boolean supportsPlatform(String platform) {
    return platforms instanceof List && platforms.contains(platform)
  }

  boolean supportsTarget(String target) {
    return targets.size() == 0 || targets.contains(target)
  }
}

def readPackageFromJavaOrKotlinFile(String filePath) {
  def file = new File(filePath)
  def fileReader = new BufferedReader(new FileReader(file))
  def fileContent = ""
  while ((fileContent = fileReader.readLine()) != null) {
    def match = fileContent =~ /^package ([0-9a-zA-Z._]*);?$/
    if (match.size() == 1 && match[0].size() == 2) {
      fileReader.close()
      return match[0][1]
    }
  }
  fileReader.close()

  throw new GradleException("Java or Kotlin file $file does not include package declaration")
}

def readFromBuildGradle(String file) {
  def gradleFile = new File(file)
  if (!gradleFile.exists()) {
    return [:]
  }
  def fileReader = new BufferedReader(new FileReader(gradleFile))
  def result = [:]
  for (def line = fileReader.readLine(); line != null; line = fileReader.readLine()) {
    def versionMatch = line.trim() =~ /^version ?= ?'([\w.-]+)'$/
    def groupMatch = line.trim() =~ /^group ?= ?'([\w.]+)'$/
    if (versionMatch.size() == 1 && versionMatch[0].size() == 2) {
      result.version = versionMatch[0][1]
    }
    if (groupMatch.size() == 1 && groupMatch[0].size() == 2) {
      result.group = groupMatch[0][1]
    }
  }
  fileReader.close()
  return result
}

def findDefaultBasePackage(String packageDir) {
  def pathsJava = new FileNameFinder().getFileNames(packageDir, "android/src/**/*Package.java")
  def pathsKt = new FileNameFinder().getFileNames(packageDir, "android/src/**/*Package.kt")
  def paths = pathsJava + pathsKt

  if (paths.size != 1) {
    return []
  }

  def packageName = readPackageFromJavaOrKotlinFile(paths[0])
  def className = new File(paths[0]).getName().split(Pattern.quote("."))[0]
  return ["$packageName.$className"]
}

def getConfig(String configKey, fallback) {
  def config = gradle.ext.unimodules.configuration
  return config.containsKey(configKey) ? config.get(configKey) : fallback
}

ext.generatePackageList = {
  def results = findUnimodules()
  def unimodules = results.unimodules
  def duplicates = results.duplicates

  def unimodulesPackagesBuilder = new StringBuilder()
  def isEmptyList = true

  for (unimodule in unimodules) {
    for (pkg in unimodule.androidPackages) {
      unimodulesPackagesBuilder.append("        new $pkg(),\n")
      isEmptyList = false
    }
  }
  if (!isEmptyList) {
    unimodulesPackagesBuilder.deleteCharAt(unimodulesPackagesBuilder.length() - 2) // remove last comma in a list
  }

  def generatedContents = generatedUnimodulesPackageListTemplate
    .replace("{{ unimodulesPackages }}", unimodulesPackagesBuilder.toString())

  def generatedCodeDir = new File(new File(project.buildDir, generatedSrcDir), generatedFilePackage.replace('.', '/'))
  def generatedJavaFile = new File(generatedCodeDir, generatedFileName)

  generatedCodeDir.mkdirs()
  generatedJavaFile.createNewFile()

  def javaFileWriter = new BufferedWriter(new FileWriter(generatedJavaFile))
  javaFileWriter.write(generatedContents)
  javaFileWriter.close()
}

def findUnimodules() {
  if (gradle.ext.unimodules.searchResults != null) {
    return gradle.ext.unimodules.searchResults
  }

  def exclude = getConfig('exclude', [])
  def modulesPaths = getConfig('modulesPaths', ['../../node_modules'])

  def unimodules = [:]
  def unimodulesDuplicates = []

  for (modulesPath in modulesPaths) {
    def baseDir = new File(rootProject.getBuildFile(), modulesPath).toString()
    def moduleConfigPaths = new FileNameFinder().getFileNames(baseDir, '**/unimodule.json', '')

    for (moduleConfigPath in moduleConfigPaths) {
      def unimoduleConfig = new File(moduleConfigPath)
      def unimoduleJson = new JsonSlurper().parseText(unimoduleConfig.text)
      def directory = unimoduleConfig.getParent()
      def buildGradle = readFromBuildGradle(new File(directory, 'android/build.gradle').toString())
      def packageJsonFile = new File(directory, 'package.json')
      def packageJson = new JsonSlurper().parseText(packageJsonFile.text)

      def unimodule = new Unimodule()
      unimodule.name = unimoduleJson.name ?: packageJson.name
      unimodule.directory = directory
      unimodule.version = buildGradle.version ?: packageJson.version ?: 'UNVERSIONED'
      unimodule.androidGroup = buildGradle.group ?: 'org.unimodules'
      unimodule.androidSubdirectory = unimoduleJson.android?.subdirectory ?: 'android'
      unimodule.platforms = unimoduleJson.platforms != null ? unimoduleJson.platforms : []
      assert unimodule.platforms instanceof List
      unimodule.targets = unimoduleJson.targets != null ? unimoduleJson.targets : []
      assert unimodule.targets instanceof List
      unimodule.androidPackages = unimoduleJson.android?.packages != null ?
          unimoduleJson.android.packages : findDefaultBasePackage(directory)
      assert unimodule.androidPackages instanceof List

      if (unimodule.supportsPlatform('android') && unimodule.supportsTarget('react-native')) {
        if (!exclude.contains(unimodule.name) && unimodule.name != 'unimodules-react-native-adapter') {
          if (unimodules[unimodule.name]) {
            unimodulesDuplicates.add(unimodule.name)
          }

          if (!unimodules[unimodule.name] ||
              VersionNumber.parse(unimodule.version) >= VersionNumber.parse(unimodules[unimodule.name].version)) {
            unimodules[unimodule.name] = unimodule
          }
        }
      }
    }
  }

  gradle.ext.unimodules.searchResults = [
      unimodules: unimodules.collect { entry -> entry.value },
      duplicates: unimodulesDuplicates.unique()
  ]
  return gradle.ext.unimodules.searchResults
}

Unimodule getUnimodule(String unimoduleName) {
  def unimodules = findUnimodules().unimodules
  return unimodules.find { it.name == unimoduleName }
}

void addDependency(Project project, Object dependency, Closure closure = {}) {
  // Previously we used `implementation` by default, but now since these dependencies are added to the adapter
  // and not the project itself, we should expose them to the project - there are some cases where
  // native unimodules code might be used in the project's code (e.g. splash screen).
  String configuration = getConfig('configuration', project.configurations.findByName('api') ? 'api' : 'compile')
  project.dependencies.add(configuration, dependency, closure)
}

void addDependencies(Project project, Closure<String> projectNameResolver) {
  def results = findUnimodules()
  def unimodules = results.unimodules
  def duplicates = results.duplicates

  if (unimodules.size() > 0) {
    println()
    println Colors.yellow('Installing unimodules:')

    for (unimodule in unimodules) {
      String relativePath = project.rootProject.buildFile.parentFile.toPath().relativize(new File(unimodule.directory).toPath())
      println """  ${Colors.green(unimodule.name)}${Colors.yellow('@')}${Colors.red(unimodule.version)} from ${Colors.magenta(relativePath)}"""
      addDependency(project, projectNameResolver(unimodule))
    }

    if (duplicates.size() > 0) {
      println()
      println Colors.yellow('Found some duplicated unimodule packages. Installed the ones with the highest version number.')
      println Colors.yellow('Make sure following dependencies of your project are resolving to one specific version:')

      println ' ' + duplicates
          .collect { unimoduleName -> Colors.green(unimoduleName) }
          .join(', ')
    }
  } else {
    println()
    println Colors.yellow('No unimodules found. Are you sure you\'ve installed JS dependencies?')
  }
}

// Make sure `ext.unimodules` exists.
if (!ext.has('unimodules')) {
  ext.unimodules = [:]
}

// This needs to be added as additional source set - look at adapter's `build.gradle`.
ext.unimodules.getGeneratedSourceDir = { return new File(project.buildDir, generatedSrcDir) }

if (rootProject instanceof ProjectDescriptor) {
  // This block runs only when file is imported by `settings.gradle`.
  // In `settings.gradle`, projects are instances of `ProjectDescriptor`
  // from which `Project` instances are created and passed to `build.gradle`.

  // Make sure `gradle.ext.unimodules` is set here.
  if (!gradle.ext.has('unimodules')) {
    gradle.ext.unimodules = [:]
  }

  // Declare variables shared between different Gradle contexts.
  gradle.ext.unimodules.configuration = null
  gradle.ext.unimodules.searchResults = null

  // These two methods below need to be available in all contexts, so we define them in `gradle.ext.unimodules`
  // as they are used in `build.gradle` and only `gradle` object is shared in those contexts.
  gradle.ext.unimodules.addDependencies = { Project project ->
    addDependencies(project) { unimodule -> project.project(":${unimodule.name}") }
  }

  gradle.ext.unimodules.addMavenDependencies = { Project project ->
    addDependencies(project) { unimodule -> "${unimodule.androidGroup}:${unimodule.name}:${unimodule.version}" }
  }

  // This is intended to be used only in `settings.gradle` so we scope it just for this context.
  ext.unimodules.includeProjects = { Map config = [:] ->
    // The configuration is shared between `settings.gradle` and `build.gradle` contexts.
    gradle.ext.unimodules.configuration = config

    Unimodule[] unimodules = findUnimodules().unimodules

    for (unimodule in unimodules) {
      include ":${unimodule.name}"
      project(":${unimodule.name}").projectDir = new File(unimodule.directory, unimodule.androidSubdirectory)
    }
  }
} else if (!gradle.ext.has('unimodules')) {
  throw new GradleException(ERR_AUTOLINKING_NOT_CONFIGURED)
}

// Merge `ext.unimodules` with `gradle.ext.unimodules` to make their properties
// easily accessible and get rid of the need to use `gradle.` prefix.
ext.unimodules << gradle.ext.unimodules
